<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Eclipse配置Maven创建web项目]]></title>
    <url>%2F2017%2F11%2F12%2FMavenCreateProject%2F</url>
    <content type="text"><![CDATA[​ 每当创建一个项目，多多少少都会需要用到各自框架或者别人造好的轮子，数据库连接需要用到驱动数据库的jar包、使用连接池也要导入jar包、SSH框架里面又是需要用到几十个jar包，并且这些jar包又有复杂的依赖关系，缺少了或者版本不适用了都会导致浪费大量的调试时间，因此，Maven就是解决这个痛点的一个工具（当然它的强大功能远远不止这点），下面就来介绍如何用Eclipse配置Maven创建web项目。 原理 以往当我们项目需要用到其他jar包时，需要到各大官网一个一个的下载下来放到我们的项目里，费时费力还容易出错。但使用Maven时，我们只需要告诉Maven我们要什么jar包，它就会自动从Maven远程仓库中将我们所需的jar包连同jar包依赖的jar包一起下载到我们本地仓库上。 由于Maven仓库服务器在墙外，所以下载速度非常慢，阿里提供了一个镜像仓库，在配置本地仓库时我们可以将阿里提供的镜像仓库作为我们下载jar包的远程仓库，下载速度能快非常多，感谢阿里！ 准备工作 Maven下载 Eclipse-neon Eclipse配置Maven的工作环境解压下好的apache-maven压缩包，找到apache-maven—&gt;conf—&gt;settings.xml复制出来。 放到Eclipse的工作空间下（也可以在其他位置，但不建议）。 在工作空间中创建本地仓库（用来存放jar包），新建文件夹命名为Repository。 用文本工具打开刚刚复制在工作空间的settings.xml配置文件，control+f查找&lt;localRepository&gt;标签，打开标签注释，把&lt;localRepository&gt;中的地址改成刚刚新建好的本地仓库的地址 control+f查找&lt;mirrors&gt;标签，打开标签注释，改成下列代码 12345&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 打开Eclipse，进入Preference偏好设置，Maven—&gt;User Settings 修改Global Settings 和 User Settings的地址，找到刚刚复制到工作空间的settings.xml配置文件，点击Apply再查看Local Repository的地址是否是我们自己创建的本地仓库的地址。 到此Eclipse的Maven环境就配置完成了。 创建Maven项目在eclipse中，File—&gt;New—&gt;Maven Project打开新建Maven对话框 然后next—&gt;选择maven-archetype-webapp 这里解释一下这些参数的含义 Group Id：项目组织的名称 Artifact Id：该项目的名称 Version：项目版本号 完成创建一个新的Maven项目 会出现index.jsp报错，先不用管它（因为缺少jar包报错） 菜单栏Window—&gt;Show View—&gt;Navigator打开导航 找到导航目录下的settings—&gt;org.eclipse.wst.common.project.facet.core.xml打开 修改版本号保存关闭 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;faceted-project&gt; &lt;fixed facet="wst.jsdt.web"/&gt; &lt;installed facet="jst.web" version="3.0"/&gt;&lt;!-- 修改版本号为3.0--&gt; &lt;installed facet="wst.jsdt.web" version="1.0"/&gt; &lt;installed facet="jst.jsf" version="2.2"/&gt; &lt;installed facet="java" version="1.8"/&gt;&lt;!-- 修改版本为1.8--&gt;&lt;/faceted-project&gt; 右键项目—&gt;Properties—&gt;Project Facets勾选Dynamic Web Services并查看版本 号是否为3.0 再打开Java Build Path—&gt;Add Library—&gt;Server Runtime选择服务器（如tomcat） 这是可以看到新建项目的目录已经变成了标准的Maven格式的目录 运行index.jsp 测试项目，浏览器打印Hello World！创建成功。 编写依赖若此项目需要连接mysql数据裤，那必然需要用到mysql数据库的驱动，我们以此为例看看如何通过Maven下载数据库驱动jar包。 打开项目目录下的pom.xml，初始状态是这样的 12345678910111213&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cloud&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; groupId : 组织标识，例如：cloud，在Repository目录下，将是: ／cloud。 artifactId : 项目名称，例如：MavenTest,在Repository目录下，将是：cloud/MavenTest目录。 version : 版本号，例如：1.0，在Repository目录下，将是：cloud/MavenTest/1.0目录。 packaging : 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par finalName：项目最终打包的名称 添加mysql-connection的依赖（从Maven中央仓库中查找所需要的jar包） 123456&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.8-dmr&lt;/version&gt;&lt;/dependency&gt; 保存可以看到Eclipse下方出现了一个下载进度条，下载完毕后查看我们的Maven依赖（第一次下载后jar包就会保存在我们的本地仓库，下次调用无需下载） 多了一个mysql驱动的jar包，证明我们Maven的依赖编写没问题。 也就是说，以后我们项目需要什么jar包，只需要在pom.xml中编写依赖就可以了。]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解线索二叉树]]></title>
    <url>%2F2017%2F08%2F21%2Fthreaded-binary-tree%2F</url>
    <content type="text"><![CDATA[线索二叉树原理遍历二叉树的其实就是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。这些线性序列中的每一个元素都有且仅有一个前驱结点和后继结点。 但是当我们希望得到二叉树中某一个结点的前驱或者后继结点时，普通的二叉树是无法直接得到的，只能通过遍历一次二叉树得到。每当涉及到求解前驱或者后继就需要将二叉树遍历一次，非常不方便。 于是是否能够改变原有的结构，将结点的前驱和后继的信息存储进来。 观察二叉树的结构，我们发现指针域并没有充分的利用，有很多“NULL”，也就是存在很多空指针。 对于一个有n个结点的二叉链表，每个节点都有指向左右孩子的两个指针域，一共有2n个指针域。而n个结点的二叉树又有n-1条分支线数(除了头结点，每一条分支都指向一个结点)，也就是存在2n-(n-1)=n+1个空指针域。这些指针域只是白白的浪费空间。因此, 可以用空链域来存放结点的前驱和后继。线索二叉树就是利用n+1个空链域来存放结点的前驱和后继结点的信息。 如图以中序二叉树为例，我们可以把这颗二叉树中所有空指针域的lchild，改为指向当前结点的前驱（灰色箭头），把空指针域中的rchild，改为指向结点的后继（绿色箭头）。我们把指向前驱和后继的指针叫做线索 ，加上线索的二叉树就称之为线索二叉树。 线索二叉树结点结构如果只是在原二叉树的基础上利用空结点，那么就存在着这么一个问题：我们如何知道某一结点的lchild是指向他的左孩子还是指向前驱结点？rchild是指向右孩子还是后继结点？显然我们要对他的指向增设标志来加以区分。 因此，我们在每一个结点都增设两个标志域LTag和RTag，它们只存放0或1的布尔型变量，占用的空间很小。于是结点的结构如图所示。 其中： LTag为0是指向该结点的左孩子，为1时指向该结点的前驱 RTag为0是指向该结点的右孩子，为1时指向该结点的后继 因此实际的二叉链表图为 线索二叉树的结构实现二叉树的线索存储结构定义如下： 1234567891011typedef char TElemType; typedef enum &#123; Link, Thread &#125; PointerTag; //Link==0,表示指向左右孩子指针 //Thread==1,表示指向前驱或后继的线索//二叉树线索结点存储结构typedef struct BiThrNode &#123; TElemType data; //结点数据 struct BiThrNode *lchild, *rchild; //左右孩子指针 PointerTag LTag; PointerTag RTag; //左右标志&#125;BiThrNode, *BiThrTree; 二叉树线索化 对普通二叉树以某种次序遍历使其成为线索二叉树的过程就叫做线索化。因为前驱和后继结点只有在二叉树的遍历过程中才能得到，所以线索化的具体过程就是在二叉树的遍历中修改空指针。 线索化具体实现以中序二叉树的线索化为例，线索化的具体实现就是将中序二叉树的遍历进行修改，把原本打印函数的代码改为指针修改的代码就可以了。 我们设置一个pre指针，永远指向遍历当前结点的前一个结点。若遍历的当前结点左指针域为空，也就是无左孩子，则把左孩子的指针指向pre(相对当前结点的前驱结点)。 右孩子同样的，当pre的右孩子为空，则把pre右孩子的指针指向当前结点(相对pre结点为后继结点)。 最后把当前结点赋给pre，完成后续的递归遍历线索化。 中序遍历线索化的递归函数代码如下： 1234567891011121314151617181920void InThreading(BiThrTree B,BiThrTree *pre) &#123; if(!B) return; InThreading(B-&gt;lchild,pre); //--------------------中间为修改空指针代码--------------------- if(!B-&gt;lchild)&#123; //没有左孩子 B-&gt;LTag = Thread; //修改标志域为前驱线索 B-&gt;lchild = *pre; //左孩子指向前驱结点 &#125; if(!(*pre)-&gt;rchild)&#123; //没有右孩子 (*pre)-&gt;RTag = Thread; //修改标志域为后继线索 (*pre)-&gt;rchild = B; //前驱右孩子指向当前结点 &#125; *pre = B; //保持pre指向p的前驱//--------------------------------------------------------- InThreading(B-&gt;rchild,pre);&#125; 增设头结点线索化后的二叉树，就如同操作一个双向链表。于是我们想到为二叉树增设一个头结点，这样就和双向链表一样，即能够从第一个结点正向开始遍历，也可以从最后一个结点逆向遍历。 如上图，在线索二叉链表上添加一个head结点，并令其lchild域的指针指向二叉树的根结点(A)，其rchild域的指针指向中序遍历访问的最后一个结点(G)。同样地，二叉树中序序列的第一个结点中，lchild域指针指向头结点，中序序列的最后一个结点rchild域指针也指向头结点。 于是从头结点开始，我们既可以从第一个结点顺后继结点遍历，也可以从最后一个结点起顺前驱遍历。就和双链表一样。 增设头结点并线索化的代码实现1234567891011121314151617181920212223//为线索二叉树添加头结点，使之可以双向操作Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)&#123; if(!(*Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) exit(OVERFLOW); //开辟结点 (*Thrt)-&gt;LTag = Link; (*Thrt)-&gt;RTag = Thread; //设置标志域 (*Thrt)-&gt;rchild = (*Thrt); //右结点指向本身 if(!T) &#123; (*Thrt)-&gt;lchild = (*Thrt); return OK; //若根结点不存在,则该二叉树为空,让该头结点指向自身. &#125; BiThrTree pre; //设置前驱结点 //令头结点的左指针指向根结点 pre = (*Thrt); (*Thrt)-&gt;lchild = T; //开始递归输入线索化 InThreading(T,&amp;pre); //此时结束了最后一个结点的线索化了,下面的代码把头结点的后继指向了最后一个结点. //并把最后一个结点的后继也指向头结点,此时树成为了一个类似双向链表的循环. pre-&gt;rchild = *Thrt; pre-&gt;RTag = Thread; (*Thrt)-&gt;rchild = pre; return OK;&#125; 遍历线索二叉树线索二叉树的遍历就可以通过之前建立好的线索，沿着后继线索依依访问下去就行。 1234567891011121314//非递归遍历线索二叉树Status InOrderTraverse(BiThrTree T) &#123; BiThrNode *p = T-&gt;lchild; while(p!=T)&#123; while(p-&gt;LTag==Link) p = p-&gt;lchild; //走向左子树的尽头 printf("%c",p-&gt;data ); while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; //访问该结点的后续结点 p = p-&gt;rchild; printf("%c",p-&gt;data ); &#125; p = p-&gt;rchild; &#125; return OK;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//函数状态结果代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码typedef int Status;typedef char TElemType;typedef enum &#123; Link, Thread &#125; PointerTag;typedef struct BiThrNode &#123; TElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag; PointerTag RTag;&#125;BiThrNode, *BiThrTree;//线索二叉树初始化Status CreateBiThrNode(BiThrTree * B) &#123; char ch; scanf("%c", &amp;ch); if(ch=='#') *B = NULL; else&#123; if(!((*B) = (BiThrNode *)malloc(sizeof(BiThrNode)))) exit(OVERFLOW); (*B)-&gt;data = ch; (*B)-&gt;LTag = Link; (*B)-&gt;RTag = Link; CreateBiThrNode(&amp;(*B)-&gt;lchild); CreateBiThrNode(&amp;(*B)-&gt;rchild); &#125; return OK; &#125;//线索二叉树线索化void InThreading(BiThrTree B,BiThrTree *pre) &#123; if(!B) return; InThreading(B-&gt;lchild,pre); if(!B-&gt;lchild)&#123; B-&gt;LTag = Thread; B-&gt;lchild = *pre; &#125; if(!(*pre)-&gt;rchild)&#123; (*pre)-&gt;RTag = Thread; (*pre)-&gt;rchild = B; &#125; *pre = B; InThreading(B-&gt;rchild,pre);&#125;//为线索二叉树添加头结点，使之可以双向操作Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)&#123; if(!(*Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) exit(OVERFLOW); (*Thrt)-&gt;LTag = Link; (*Thrt)-&gt;RTag = Thread; (*Thrt)-&gt;rchild = (*Thrt); if(!T) &#123; (*Thrt)-&gt;lchild = (*Thrt); return OK; //若根结点不存在,则该二叉树为空,让该头结点指向自身. &#125; BiThrTree pre; //令头结点的左指针指向根结点 pre = (*Thrt); (*Thrt)-&gt;lchild = T; //开始递归输入线索化 InThreading(T,&amp;pre); //此时结束了最后一个结点的线索化了,下面的代码把头结点的后继指向了最后一个结点. //并把最后一个结点的后继也指向头结点,此时树成为了一个类似双向链表的循环. pre-&gt;rchild = *Thrt; pre-&gt;RTag = Thread; (*Thrt)-&gt;rchild = pre; return OK;&#125;//非递归遍历线索二叉树Status InOrderTraverse(BiThrTree T) &#123; BiThrNode *p = T-&gt;lchild; while(p!=T)&#123; while(p-&gt;LTag==Link) p = p-&gt;lchild; //走向左子树的尽头 printf("%c",p-&gt;data ); while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; //访问该结点的后续结点 p = p-&gt;rchild; printf("%c",p-&gt;data ); &#125; p = p-&gt;rchild; &#125; return OK;&#125;int main() &#123; BiThrTree B,T; CreateBiThrNode(&amp;B); InOrderThreading(&amp;T,B); printf("中序遍历二叉树的结果为："); InOrderTraverse(T); printf("\n");&#125;//测试数据:abc##de#g##f### 参考资料 线索二叉树的建立与遍历C语言实现过程详解 Threaded Binary Tree 动画：中序线索化二叉树 《大话数据结构》 《数据结构》—严蔚敏]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线索二叉树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法详解]]></title>
    <url>%2F2017%2F08%2F17%2FKMPAlgorithm%2F</url>
    <content type="text"><![CDATA[传统的字符串匹配模式（暴力循环）子串的定位操作通常称作串的串的匹配模式，也就是在主串S中查找模式串（子串）T第一次出现的位置。如比较以下两个串： 12主串S：ABCDABX子串T：ABX 我们可以通过暴力循环的方式依次的比较S[i]和T[j]，若匹配失败，则子串向前移位1步，重新开始匹配，直至匹配完成。 12主串S：ABCDABX子串T： ABX（匹配成功） 传统的暴力循环代码如下： 12345678910111213141516int index(String S,String T)&#123; int i,j; i = j = 0; while(i&lt;StrLength(S) &amp;&amp; j&lt;StrLength(T))&#123; if(S[i] = T[i])&#123; i++; j++; &#125; //继续比较后续字符 else&#123; i = i - j + 1; j = 0; &#125; //指针后退重新开始匹配 &#125; if(j &gt; StrLength(T)) return i - StrLength(T) + 1; //返回定位 return 0; //匹配失败&#125; 这种传统的模式匹配方式最坏的情况下需要循环mxn次，时间复杂度为O(mxn)，因为主串中可能存在多个和模式串“部分匹配”的子串，因此指针多次回溯，效率极低。 KMP算法的匹配过程KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。用以下例子说明： 主串：abcababca…（假设主串很长，我们就先看前9位） 子串：abcabx 按照传统的匹配模式的过程就应该如下： 传统的匹配模式，就应该是按照上面的方式一步一步的匹配下来，一旦匹配失败，主串指针i就要回溯，效率非常低！而KMP算法的匹配过程只需要两步： 为什么一下次就可以跳过中间的比较来到这一步呢，下面就来探究KMP算法的匹配方式。 先来对比一下传统的匹配模式，可以发现主串的指针i值的变化： 第一次遍历到了i=6，匹配失败； 第二次遍历到了i=2，匹配失败； 第三次遍历到了i=3，匹配失败； 第四次遍历到了i=4，匹配失败； 第五次遍历到了i=5，匹配失败； 直到第五次i值终于又回到了i=6。 i值的变化情况：6-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 在传统的匹配算法中，可以发现i值是不断回溯的。 反观KMP算法，只需对主串一次遍历，i值不会回溯，即遍历过程中i值是不会变小的。 那么既然KMP算法的i值遍历只需一次，那么就要考虑j是如何变化的了，为什么第一次匹配失败后j可以从j=3开始匹配，而不像传统遍历算法那样每当匹配失败就要从j=1重新开始匹配。 再看看一开始对KMP算法的定义：KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。 划重点：利用匹配失败后的信息。什么是匹配失败后得到的信息呢？ 于是回到刚刚的第一次匹配，看看能从这次失败的匹配中得到什么信息。 因为S[1…5] = T[1…5] 所以有 S[1,2] = T[1,2] S[4,5] = T[4,5] 又因为子串T有 T[1,2] = T[4,5]，所以S[4,5] = T[1,2] 那下一次滑动到直接让S[4,5] = T[1,2]，然后继续比较下一个元素就行啦。 这是简化模型第一次匹配的情况，根据传统的匹配算法，当匹配失败时模式串T移动一格，和S串比较。但是由于绿色部分在第一次匹配的时候发现了额外的信息： 就像刚刚那个例子，T[1,2] = S[4,5]，都这样了，难道T还需要一格格的移动吗，直接滑过去就行啦。 这就是KMP算法的匹配过程。 如何确定模式串的滑动区间 知道了KMP算法的匹配过程，接下来就要考虑计算机是如何知道匹配失败时，指针j下一次指向的位置。由于KMP算法中指针i是不减的，因此j的指向位置只与模式串本身的结构有关。j的滑动位置的信息存放在next数组中。当匹配失败，就可以通过查询next数组的值得到下一次j滑动的位置。 next数组存放的是模式串的移位信息，具体就是模式串的部分匹配值，next数组大小与模式串T等长。 部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， － “A”的前缀和后缀都为空集，共有元素的长度为0； － “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； － “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； － “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； － “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 下面是模式串T：a b c d a b c a | next数组的推导过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 j i模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0T[j]≠T[j] i++ next[i] = 0 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0T[j]≠T[j] i++ next[i] = 0 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0 0T[j]≠T[j] i++ next[i] = 0 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0 0 1T[j]=T[j] i++ j++ next[i] = j+1 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0 0 1 2T[j]=T[j] i++ j++ next[i] = j+1 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0 0 1 2 3T[j]=T[j] i++ j++ next[i] = j+1 j i 模式串：a b c d a b c a串下标：0 1 2 3 4 5 6 7next ：0 0 0 0 1 2 3T[j]≠T[j] j = next[j-1] j i 模式串：a b c d a b c a j ：0 1 2 3 4 5 6 7next ：0 0 0 0 1 2 3 1T[j]=T[j] next[i] = j+1 最后得到 next[] = &#123;0,0,0,0,1,2,3,1&#125; C语言的next数组实现如下： 123456789101112131415161718192021void get_next(String T,int next[])&#123; int j = 0; int i = 1; next[0] = 0; while(i&lt;StrLength(T))&#123; if(T[i] == T[j])&#123; next[i] = j + 1; ++j; ++i; &#125; else&#123; if(j!=0)&#123; j = next[j-1]; &#125; else&#123; next[i] = 0; ++i; &#125; &#125; &#125;&#125; 有了next数组，我们就可以知道每当KMP匹配过程中，一旦匹配失败，我们就令指针 j = next[j-1] ，然后继续与S[i]比较。 KMP完整算法如下： 12345678910111213141516171819202122int KMP(String S,String T)&#123; int length_S = StrLength(S); int length_T = StrLength(T); int next[length_T]; get_next(T,next); int i = 0; int j = 0; while(j&lt;length_T &amp;&amp; i&lt;length_S)&#123; if(T[j] == S[i])&#123; ++i; ++j; &#125; else&#123; if(j!=0) j = next[j-1]; else ++i; &#125; &#125; if(j==length_T) return i - length_T +1; return 0;&#125; 文章参考 字符串匹配的KMP算法 详解KMP算法 CODE 《大话数据结构》 《数据结构》—严蔚敏]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库复习大纲（四）]]></title>
    <url>%2F2017%2F06%2F24%2Fdatabase-review-outline-4%2F</url>
    <content type="text"><![CDATA[第九章1.查询优化一般分为哪两种查询优化一般可分为代数优化（也称逻辑优化）和物理优化（也称非代数优化）。代数优化是指关系代数表达式的优化，即按照一定规则，通过对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询执行更加高效；物理优化则是指通过存取路径和底层操作算法的选择进行的优化。 2.实现选择操作的两种算法、连接操作的四种算法分别是什么选择操作的两种实现1SELECT* FROM Student WHERE &lt;条件表达式&gt; (1). 简单的全表扫描假设可以使用的内存为M块，全表扫描算法思想如下： 按照物理次序读Student的M块到内存 检查内存的每个元组t，如果t满足选择条件则输出t 如果Student还有其他块未被处理，重复1和2 。 对于规模较小的表，这种算法简单有效。但对于规模较大的表进行顺序扫描，当选择率较低时，这个算法效率很低。 (2)索引扫描算法如果选择条件中的属性上有索引，可以使用索引扫描方法，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组。 例如查找条件表达式为Sno=&#39;201701的学生，并且Sno上有索引，就可以使用索引得到Sno为201701的学生，再通过元组指针在Student表上找到该学生。 一般情况下，当选择了较低时，基于索引的选择算法要优于全表扫描算法。但当选择率较高，要查找的元组均匀分布在查找的表中，这时基于索引的选择算法性能不如全表扫描算法。 连接操作的四种实现1SELECT* FROM Student,SC WHERE Student.Sno = SC.Sno (1)嵌套循环算法这时最简单可行的算法。对外层循环的每一个元组，检索内层循环中的每一个元组，并检查这两个元组在连接属性(Sno)上是否相等。 (2)排序—合并算法这时等值连接常用的算法，尤其适合参与连接的诸表已经排序好的情况。 如果参与排序的表没有排序，首先对Student表和SC表按属性Sno进行排序。 取Student表中的第一个Sno，依次扫描SC表中具有相同Sno的元组并连接。 当扫描到Sno不相等的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组并连接。 重复上述步骤直至Student表扫描完毕。 (3)索引连接算法 在SC表上已经建立了属性Sno的索引 对Student中的每一个元组，由Sno值通过SC索引查找相应的SC元组 把这些SC元组和Student元组连接起来 (4)hash join 算法hash join算法也是处理等值连接的算法。它把属性作为hash码，用同一个函数把Student表和SC表中的元组散列到hash表中。 划分阶段，也称创建阶段，即创建hash表。对包含较少元组的表进行一遍处理，把它的元组按hash函数分散到hash表的桶中； 试探阶段，也称连接阶段，对另一个进行一遍处理，把SC表的元组也按同一个hash函数进行散列，找到适当的桶，并且把SC元组与桶中来自Student表并与之相匹配的表连接起来。 3.掌握将查询语句转化成语法树的表示方法。123SELECT Student.Sname FROM Student，SC WHERE Student.Sno=SC.Sno AND SC.Cno=‘2’； 4.在查询优化中，选择运算应尽可能先做第十章1.事务的概念和特性所谓事务是用户定义的一个数据库操作序列，这些操作要嘛全做，要么全不做，是一个不可分割的工作单位。 事务具有四个特性：原子性、一致性、隔离性和持续性。 原子性：事务是数据库的逻辑工作单位，事务中包括的诸操作要嘛都做要嘛都不做。 一致性：事务的执行结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交结果时，就说数据库处于一致性状态。 隔离性：一个事务执行不能被其它事务干扰。 持续性：一个事务一但提交，数据库中的数据的改变就是永久性的。 2.在SQL Server中有哪些定义事务的语句BEGIN TRANSACTION ：开始一个显式事务。 COMMIT TRANSACTION ：标识一个显式事务或隐式事务正常结束而提交。 SAVE TRANSACTION ：在事务内定义一个检查点标记。 ROLLBACK TRANSACTION ：回滚当前事务。 3.数据库系统有几类故障，恢复的实现技术是什么故障类型(1)事务故障更多的是非预期的事务故障 事务由于某些内部条件无法继续正常执行 如：非法输入、找不到数据、溢出等 (2)系统故障系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。 如：CPU故障、操作系统故障、系统断电等 (3)介质故障系统故障称为软故障，介质故障称为硬故障，指外存故障。 如：磁盘损坏、瞬间强磁场干扰等 (4)计算机病毒恢复实现技术建立冗余数据，利用冗余数据实施数据库恢复。建立数据冗余最常用的技术是数据转储和登记日志文件。 (1)数据转储数据库管理员定期将整个磁带、磁盘复制到其他存储介质保存起来的过程。 (2)登记日志文件日志文件是用来记录事务对数据库的更新操作文件。 4.根据日志记录，判断系统故障发生时刻事务该采取的操作（参考课后习题4，5） 以系统故障点为分界线。若故障前事务已完成则执行重做，若故障后事务仍为完成则回滚。 第十一章1.并发操作带来哪三种数据不一致性(1)丢失修改两个事务T1、T2同时读入一数据，T2提交的结果破坏了T1提交的结果，导致T1数据丢失。 (2)不可重复读事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。 (3)读脏数据事务T1修改某一数据并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，T1修改后的数据恢复原值，T2读到的数据就与数据库中的数据不一致，T2读到的数据就称为“脏数据”。 2.封锁的类型、相容矩阵、封锁粒度封锁类型 封锁的基本类型有两种：排他锁（简称X锁）和共享锁（简称S锁）。 排他锁又称写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，任何其他食物都不能再对A加任何锁，直至T释放A上的锁为止。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 共享锁又称读锁。若事务T对A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直至T释放A上的S锁为止，这就保证了其他事务可以读A，但是在T释放A上的S锁之前不能对A进行任何修改。 封锁粒度 封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元，也可以是物理单元。以关系数据库为例，封锁对象可以是这样一些逻辑单元：属性值、属性值的集合、元组、关系、索引项直至整个数据库；也可以是这样一些物理单元：页、物理记录等。 封锁粒度与系统的并发度和并发控制的开销密切相关。封锁粒度越大，数据库所能封锁的数据单元就越少，并发度越小，系统开销也越小；反之。并发度越高，系统开销也越大。 3.什么是死锁事务T1封锁了数据R1，事务T2封锁了数据R2.然后T1又请求R2，因为T2已经封锁了R2，于是T1等待T2释放R2上的锁；接着T2又申请封锁R1，因为T1也已经封锁了R1，T2也只能等待T1释放R1上的锁。这样就形成了T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。 4.什么是可串行化调度多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，这种调度策略为可串行化调度。 可串行性是并发事务正确调度的准则 5.根据给定的事务设计调度策略（参考课后习题9）]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库复习大纲（三）]]></title>
    <url>%2F2017%2F06%2F23%2Fdatabase-rebiew-outline-3%2F</url>
    <content type="text"><![CDATA[第七章1.数据库设计的特点是什么，可分为哪6个阶段特点： “三分技术、七分管理、十二分基础数据”是数据库设计的特点之一。 数据库设计过程中把数据库结构设计和对数据的处理设计密切结合起来， 六个阶段： 分别为需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施和数据库维护和运行。 2.掌握概念设计和逻辑设计方法(E-R图，转化成关系模式等)，要会对给定的实例进行分析(1)ER图转关系模式方法ER模型中的主要成分是实体和联系。 对于实体，可以这样转换：将每个实体转换成一个关系模式，实体的属性即为关系模式的属性，实体的关键字即为关系模式的主码。 实体 → 关系 属性 → 关系的属性 (2)联系为M：N的转换方法若实体间联系是M:N，则将联系也转换成关系模式，其属性为两端实实体的主码加上联系的属性，其主码为两端实体主码的组合。 S(S#, SNAME ,AGE,SEX ) C(C#, CNAME ,TEACHER) SC(S#,C#,GRADE) (3)联系为1：N的转换方法若实体间的联系是1:N的，则在N端实体转换成的关系模式中加入1端实体转换成的关系模式的主码和联系的属性。 车间模式（车间编号，车间名，电话） 职工模式（工号，姓名，性别，年龄，车间编号，聘期） (4)联系为1：1的转换方法若实体间的联系是1:1的，可以在两个实体转换成的两个关系模式中任意一个关系模式的属性中加入另一个关系模式的主码和联系类型的属性。 学校模式（校名，地址，电话，校长名，任职年月） 校长模式（姓名，年龄，性别，职称） (5)实例 商店（商店编号，商店名，地址） 职工（职工编号，姓名，性别，业绩，商店编号，聘期，月薪） 商品（商品号，商品名，规格，单价） 销售（商店编号，商品号，月销售量） 3.掌握ER图的集成方法。要解决哪三类冲突？ER图集成分两步走： 合并E-R图，生成初步E-R图 修改和重构。消除不必要的冗余，生成基本ER图 消除冲突因为局部应用不同,设计人员不同,所面向的问题不同，从而造成的各局部ER图的不一致。冲突包括属性冲突、命名冲突和结构冲突。 属性冲突 属性域冲突，即属性值的类型、取值范围或取值集合不同。 例如零件号，有的部门把它定义为整数，有的部门把它定义为字符型。 属性取值单位冲突 例如，零件的重量以公斤、斤、克为单位。 命名冲突 同名异义，即不同意义的对象在不同的局部应用中具有相同的名字。 异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。 结构冲突 同一对象在不同应用中具有不同的抽象。 例如，职工在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。 同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同。 实体间的联系在不同的E-R图中为不同的类型。 4.数据库实施包含哪些工作数据库实施包含两项重要的工作，一项是数据的载入，另一项是应用程序的编码。 第八章1.游标定义和使用的SQL命令动词定义游标：定义一个游标，使之对应一个select语句。 1EXEC SQL DECLARE &lt;游标名&gt; CURSOR FOR &lt;SELECT语句&gt; 打开游标：打开一个游标，执行游标对应的查询，结果集合为该游标的活动集。 1EXEC SQL OPEN &lt;游标名&gt; //定位于查询结果第一行的前一行 游标推进语句：在活动集中将游标移到特定的行，并取出该行数据放到相应的宿主变量中 1EXEC SQL FETCH &lt;游标名&gt; INTO &lt;主变量名&gt; 游标关闭语句：关闭游标，释放活动集及其所占资源，使它不再和查询结果相联系。需要再使用该游标时，执行open语句。 1EXEC SQL CLOSE &lt;游标名&gt; 2.创建和执行存储过程的SQL语句创建存储过程123格式：CREATE Procedure 过程名（［参数1，参数2，...］） AS&lt;PL/SQL块&gt;； 过程名：数据库服务器合法的对象标识。 参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数。默认为输入参数。 过程体：是一个。包括声明部分和可执行语句部分。 执行存储过程12格式： CALL/PERFORM Procedure 过程名(［参数1，参数2，...］)； 使用CALL或者PERFORM等方式激活存储过程的执行。 在PL/SQL中，数据库服务器支持在过程体中调用其他存储过程 3.ODBC应用系统包含哪4个部分ODBC应用系统由四部分构成：用户应用程序、ODBC驱动程序管理器、数据库驱动程序、数据源（关系数据库系统和数据库）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库复习大纲（二）]]></title>
    <url>%2F2017%2F06%2F22%2Fdatabase-review-outline-2%2F</url>
    <content type="text"><![CDATA[第六章1.一个不好关系模式通常存在哪四种问题 数据冗余 更新异常 插入异常 删除异常 2.理解并会判断属性的函数依赖关系，平凡、部分、传递函数依赖关系、候选码、主码、主属性、非主属性、全码 函数依赖定义设关系模式R（U），属性集合U={A1，A2，…，An}，X，Y为属性集合U的子集，如果对于关系模式R(U)的任一可能的关系r，r中的任意两个元组u、v，若有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X。用符号X→Y表示。其中X为决定因素，Y为被决定因素。若对于R（U）的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值性等，而在Y上的属性值不等。 函数依赖是语义范畴的概念，只能根据语义来确定一个函数依赖关系。 函数依赖X→Y的定义要求关系模式R的任何可能的关系r中的元组都满足函数依赖条件。 函数依赖与属性间的联系类型的关系•若属性X和Y之间有“一对一”的联系,则X→ Y,Y → X,X &lt;–&gt; Y.（如不存在同名的学号和姓名） •若属性X和Y之间有“多对一”的联系,则X → Y,但Y -/-&gt; X. •若属性X和Y之间有“多对多”的联系,则X与Y之间不存在任何函数依赖. 当确定函数依赖关系时,可从属性间的联系入手 术语 若X→Y，则X称作决定因素（Determinant） 若X→Y，Y→X，称作X&lt;–&gt;Y。 若Y不函数依赖于X，称作X -/-&gt; Y。 X→Y，若Y不是X的子集，则称X→Y为非平凡的函数依赖。正常讨论的都是非平凡的函数依赖。 X→Y，若Y是X的子集，则称X→Y为平凡的函数依赖。 完全函数依赖(full functional dependency)：在R(U)中，设X、Y是关系模式R（U）中不同的属性子集，若存在 X→Y，且不存在 X的任何真子集X’，使得 X’→Y，则称Y完全函数依赖 ( full functional dependency ) 于X。记作 X-F-&gt;Y。 例如：（学号、课程）→成绩就是完全依赖函数，因为（学号、课程）的真子集不论是学号还是课程，都无法推出成绩。 部分函数依赖：在关系模式R（U）中，X、Y是关系模式R（U）中不同的属性子集，若X→Y成立，如果X中存在任何真子集X’，而且有X’→Y也成立，则称Y对X是部分函数依赖，记作：X-P-&gt;Y。 例如，（学号、课程）→所在系就是部分依赖函数，因为学号→所在系，而学号是（学号、课程）的真子集。 码超码：设X为关系R的属性或属性组，U为R的元组.若X→U，则称X为R的超码。 候选码：设X为R的超码，若X中不含多余属性，则称X为R的候选码。 主码：若关系R有多个候选码，则可以从中选定一个作为R的主码。 主属性：包含在任何一个候选码中的属性，称作主属性，不包含在任何码中的属性称为非主属性。 全码(all-key)：关系模式的码由整个属性组构成。 3.理解1NF、2NF、3NF、BCNF、4NF的特点并判断第一范式（1NF）关系模式R的所有的属性值域都是不可再分的。即不能以集合、序列等作为属性值。 第二范式（2NF）对于关系模式R，若R∈1NF，且R中的每一个非主属性完全函数依赖于R的某个候选键，则R∈2NF（消除非主属性对键的部分依赖） sc(sno,sname,cno,grade) sno→sname 非主属性部分依赖主键 可以划分为 sc(sno,cno,grade) s(sno,sname) 第三范式（3NF）如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选码，则称R是第三范式(3NF)的模式。则称R∈3NF（消除非主属性对键的传递依赖） s(sno,sname,sdept,dept_manager) sno→sname,sdept sdept→dept_manager 存在传递依赖：sno→dept_manager 可以划分为 s (sno,sname,sdept) d(sdept,dept_manager) BCNF如果关系模式R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式。 sct(s,c,t) //学生，课程，教师 （s，t），（s，c）为候选键。 t→c //每位教师只上一门课 s,c→t //某学生选定一门课，就对应一位老师 s,t→c //每门课有若干位教师；但某学生选定 ​ 一位老师，就对应一门课 sct属于3NF 但不属于BCNF 简单的判断方法： 找出候选码，如上例（S，t），（S，C）为候选码 找出依赖关系 每一个决定属性集是否都包含候选码（箭头左边是不是候选码） 第四范式（4NF）4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。 4.理解多值依赖关系、平凡多值依赖关系的含义设R(U)是属性集U上的一个关系模式。X，Y，Z是U的子集,并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r,给定的一对(x，z)值有一组Y的值，这组值仅仅决定于x值而与z值无关。 若X→→Y，而Z＝Ø，则称X→→Y为平凡的多值依赖。否则称X→→Y为非平凡的多值依赖。 关系模式WSC(W,S,C)中，W表示仓库，S表示保管员，C表示商品。假设每个仓库有若干个保管员，有若干种商品。每个保管员保管所在仓库的所有商品，每种商品被所有保管员保管。 W S C W1 S1 C1 W1 S1 C2 W1 S1 C3 W1 S2 C1 W1 S2 C2 W1 S2 C3 W2 S3 C4 W2 S3 C5 W2 S4 C4 W2 S4 C5 对于W的每一个值，不论C取什么值，S有一个完整的集与它对应所以W→→ S 由于C和S完全对称，所以必然W→→ C成立 5.多值依赖与函数依赖的区别是什么(1) X→Y的有效性仅决定于X、Y属性集上的值，它在任何属性集W（W ∈ U）上都成立。 X→→Y在属性集W（XY ∈W ∈ U）上成立，但在U上不一定成立。因为多值依赖的定义中不仅涉及属性组X和Y，而且涉及U中其余属性Z。 (2) 若X→→Y在R(U)上成立，则不能断言对于Y′ ∈ Y，是否有X→→Y ′成立。 若X→Y在R(U)上成立，则对于Y′ ∈ Y，有X→Y ′成立。 6.运用关系运算律完成关系模式的规范化 7.如何计算闭包F为关系模式R(U)的函数依赖集，我们把F以及所有被F逻辑蕴涵的函数依赖的集合称为F的闭包，记为F+。 示例1: 对关系R（A,B,C,D,E,F）,给定函数依赖AB→C,BC→AD,D→B,CF→B,求 {A，B}+ {AB}+=AB {AB}+=ABC //AB→C {AB}+=ABCD //BC→AD {AB}+=ABCD //D→B 示例2: R (A, B, C, G, H, I), F = {A→B, A→C, CG→H, CG→I, B→H},计算(AG)F+ 所用依赖 (AG)F+ A→B AGB A→C AGBC CG→H AGBCH CG→I AGBCHI (AG)F+ = AGBCHI 8.理解无损连接性和保持函数依赖的概念并判断无损连接的判断 建立一张n列k行的表，每一列对应一个属性，每一行对应分解中的一个关系模式。若属性Aj属于Ui，则在j列i行上真上aj，否则填上bij； 依次考察每一个依赖关系FDi（Xi→Ai），找到Xi所对应的列，并且列中元素为ai的行，所对应的Ai中的元素是否有ai，如果有，则全部改成ai，反之则全部改成bmj，m为这些行号最小值。 直到表格中出现一行为a1, a2 , … , an 的一行。说明是无损连接。反之则为有损。 保持函数依赖的判断看懂就行。 9.如何计算关系的最小依赖集。掌握无损连接的BCNF分解算法，掌握无损连接、保持依赖的3NF分解算法。最小依赖集每个函数依赖集F都可以被一个右部只有单属性的函数依赖集G所覆盖。 满足下列条件的函数依赖集F称为最小函数依赖集合，记作Fmin： 右边单属性化：F中任一函数依赖X→ A，A必是单属性。 无冗余依赖：F中不存在这样的函数依赖X → A，使得F与F - {X →A}等价。 无冗余决定属性：F中不存在这样的函数依赖X → A，在X中有真子集Z，使得F与（F - {X → A}） È {Z → A}等价。 无损连接、保持依赖的3NF分解算法输入：关系模式R（A、B、C、D … ）及依赖关系F 输出：R的一个分解{R1,R2,R3} 求出最小依赖集Fmin 对Fmin中左边相同的进行合并（反右边单属性化） 对Fmin中的每一个依赖关系构成一个关系模式 到此完成保持依赖的3NF关系模式R` 找到原关系模式R中的候选码 若R`中的任一关系都不包含候选码，则候选码单独构造一个关系模式。 分解结束，输出。 无损连接的BCNF分解算法⒈置r = {R} ⒉检查r中各关系模式是否为BCNF，若是，则转4算法终止。 ⒊设r 中一个关系模式R不是BCNF， 则S中存在函数依赖X→A，A不属于X ，且X不是S的键， 设S1=XA,S2=S-A,用分解{S1，S2}代替S ，返回到⒉ 4.分解结束，输出r。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库复习大纲（一）]]></title>
    <url>%2F2017%2F06%2F22%2FDatabase-review-outline1%2F</url>
    <content type="text"><![CDATA[第一章1.什么是数据库？数据库数据有哪三个基本特点？数据库是长期储存在计算机内，有组织，可共享的大量数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享 2.数据库管理系统有哪些功能？ 数据定义功能 数据组织、存储和管理功能 数据操作功能 数据库事务管理和运行管理 数据库的建立和维护功能 其他 3. 数据库系统有几个特点？它与文件系统的本质区别是什么？(1)数据结构化数据库系统实现整体数据结构化，这是数据库的主要功能之一，也是数据库系统与文件系统的本质区别。 文件系统中，记录的结构和记录之间的联系被固化在程序中，需要由程序员加以维护，既加重了程序员负担，又不利于结构变动 (2)数据的共享性高，冗余度低且易扩充数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。 (3)数据独立度高物理独立性：用户的应用程序与数据库中数据的物理结构是相互独立的。 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。 (4)数据由数据库管理系统统一管理和控制数据库的共享将会带来数据库的安全隐患，为此数据库管理系统提供了数据库的安全性保护、数据库的完整性检查、并发控制和数据库恢复的数据控制功能。 4.理解概念模型中的基本概念概念模型实际上是现实世界到机器世界的一个中间层次，它用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具。 信息世界中的主要概念： 实体 客观存在并可相互区别的事务称为实体 属性 实体所具有的某一特性称为属性，用椭圆形表示 码（key） 唯一标识实体属性集称为码 实体型 用实体名及属性名集合来抽象和刻画同类实体，称为实体型，矩形框表示 实体集 同一类型实体的集合，如全体学生 联系 不同实体集之间的联系，有1V1、1Vn、nVn等多种类型 概念模型的一种表示方式：实体联系方法（ER模型） 5.什么是数据模型的三要素？有几种常用的数据模型。数据模型三要素：数据模型是严格定义的一组概念的集合，数据模型的三要素是数据结构、数据操作和完整性约束三部分组成。 数据结构：描述数据库的组成对象以及对象之间的联系。是对系统静态特征的描述。 数据操作：数据库中各种对象的实例允许执行的操作的集合，包括操作及有关操作规则。数据操作是对系统动态特征的描述。 数据库的完整性约束条件：是一组完整性规则。 常用的数据模型：(1) 层次模型优点 层次模型的数据结构比较简单清晰 层次数据库的查询效率较高 提供了良好的完整性支持 缺点 现实世界很多联系是非层次的，如多对多 如果一个结点具有多个双亲结点，引入冗余，使应用程序编写复杂 查询子女结点必须通过双亲节点 由于结构严密，层次命令趋于程序化 (2)网状模型优点 能够更为直接的描述现实世界 具有良好的性能，存取效率高 缺点 结构复杂，不利于最终用户掌握 网状模型的DDL、DML复杂，用户不容易掌握和使用 记录之间联系是通过存储路径实现的，因此用户必须掌握结构细节，加重编写应用程序的负担。 (3)关系模型优点 关系模式与格式化模型不同，它建立在严格的数学概念的基础上 关系模型的概念单一，数据结构简单、清晰，用户易懂易用 关系模型的存取路径对用户透明，具有更高的数据独立性、更好的安全保密性，也简化了程序员工作和数据库开发建立的工作 6.数据库系统的三级模式结构和两层映像。特点是什么？ 三级模式1.模式模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层。 2.外模式外模式也称子模式或用户模式，他是数据库用户能够看见和使用的局部数据的逻辑结构和特征描述，是数据库用户的数据视图，是与某一用户有关的数据的逻辑表示。 3.内模式内模式也称存储模式，一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。 两层映像1.外模式／模式映像模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构，对于同一个模式可以有任意多个外模式，对于每一个外模式，数据库系统都有一个外模式／模式映像，它定义了该外模式与模式的对应关系。 当模式改变时，由数据库管理员对各个外模式／模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。 2.模式／内模式映像数据库中只有一个模式，也只有一个内模式，所以模式／内模式映像是唯一的，它定义了数据全局逻辑与存储结构之间的对应关系。当数据库的存储结构改变时，由数据库管理员对模式／内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。 7.开发、管理和使用数据库的人员有哪几类？ 1.数据库管理员（DBA）负责全面控制和管理数据库系统 2.系统分析员和数据库设计人员分析员负责应用系统的需求分析和规范说明，参与数据库系统概要设计 设计人员负责数据库中数据的确定及数据库各级模式的设计 3.应用程序员负责设计和编写应用系统模块，并进行调试和安装 4.用户指最终用户，通过应用系统的用户接口使用数据库 第二章1.理解关系的有关术语并会判断(1)域一组具有相同数据类型的值的集合 例如：自然数、整数、长度小于25字节的字符串集合、{0,1}、{男、女}等 (2)笛卡尔积笛卡尔积是域上的一种集合运算，就是把两个表相乘。 一个域允许的不同取值个数称为这个域的基数 1D1×D2×···×Dn=&#123;(d1,d2,···,dn) | di∈Di，i=1,2,···，n&#125; 例子，设有两个域：姓名集D1={李倩，王刚，张体宁} 和 性别集D2={男，女}。则： 1设有两个域：姓名集D1=&#123;李倩，王刚，张体宁&#125; 和 性别集D2=&#123;男，女&#125;。 这六个元组可构成一张二维表，表中部分元组称作其子集。 D1 D2 李倩 女 王刚 女 张体宁 女 李倩 男 王刚 男 张体宁 男 (3)关系D1xD2xD3…Dn的子集叫做在域D1，D2，…，Dn上的关系 候选码的定义：如果关系中的某一属性组的值能唯一地标识一个元祖，则称该属性组为候选码； 主码的定义：如果一个关系有多个候选码，则选定其中一个为主码； 主属性定义：候选码的诸属性称为主属性； 非主属性定义：不包含在任何候选码中的属性称为非主属性； 全码：最极端的情况下，所有属性都为候选码，成为全码 关系的三种类型：基本关系（基本表）、查询表和视图表。基本表是实际存在的表，它是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。 2.理解基本关系的6条性质 列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。 不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。 列的顺序无所谓，即列的次序可以任意交换。 任意两个元组的候选码不能取相同的值 行的顺序无所谓，可以任意交换 分量必须取原子值，即每一个分量是不可分的数据项（最基本的一条） 3.理解实体完整性、参照完整性的规则并举例关系模式中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。 (1)实体完整性规则若一个属性A是基本关系R的主属性，则A不能取空值。 例如：学生（学号、姓名、性别、专业号、年龄）关系中学号为主码，则学号不能取空值。 如果主码由若干属性组成，则这些主属性都不能取空值 例如：选修（学号、课程号、成绩）关系中，“学号、课程号“为主码，则两个属性都不能取空值 对于实体完整性规则如下： 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。 现实世界中的实体是不可区分的，即他们具有某种唯一性标识。例如每个学生都是独立的个体。 关系模型中的主码作为唯一性标识。 主码的属性既主属性不能取空值。 (2)参照完整性规则若属性F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中的每个元组F上的值必须： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 例如： 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） 学生关系中的每个元组的“专业号”属性只能取下面两类值： 空值，表示尚未给该学生分配专业 非空值，该值必须对应专业关系中某个元组的“专业号”值 4.理解关系的外码、参照关系、被参照关系设F是基本关系R的一个或一组属性，但不是关系的码，Ks是基本关系S的主码。如果F和Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系 5.理解元组、分量、连接、象集等概念和记号表示及判断每一个元素{d1，d2，…，dn}叫做一个n元组，或简称元组。元素中的每一个值di叫做一个分量。 连接也称θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作 12R∞S=&#123;tr ts|(tr∈R) ∧ (ts ∈S) ∧ tr[A] θ ts[B] &#125;AθB 连接运算从R和S的笛卡尔积RxS中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 象集的概念。在关系R中属性A可以取四个值｛a1,a2,a3,a4}其中a1的象集为｛(b1,c2),(b2,c3),(b2,c1)}a2的象集为｛(b3,c7),(b2,c3)}a3的象集为｛(b4,c6)}a4的象集为｛(b6,c6)} R: A B C a1 b1 c2 a2 b3 c7 a3 b4 c6 a1 b2 c3 a4 b6 c6 a2 b2 c3 a1 b2 c1 6.理解各种关系代数运算及特点。要求分析给定关系的运算结果；以及根据要求完成的操作结果给出相应的运算式关系运算包括：选择、投影、连接、除等。 设t为R的元组变量，R(U)=R(A1，A2，···，An)，则引入记号： t[A]：表示关系R在A属性（组）上的所有值。 选择选择是在关系行上进行的元组挑选，结果产生同类关系。运算表达式如下： σF(R)={t | t∈R ∧ F(t)=true } σF(R)表示从关系R中选出满足条件表达式F的那些元组所构成的关系。其中F由属性名（值）、比较符、逻辑运算符组成。 看个例子 R: A1 A2 A3 a 2 d a 3 f b 2 d c 2 d e 6 f g 6 f 则σA2&gt;5 (R) A1 A2 A3 e 6 f g 6 f 投影投影运算时在关系列上进行的选择，结果产生不同类关系。运算式表示如下： ΠA(R)={t[a] | (t∈R)} 继续使用上面的例子，上面例子中对应的ΠA3,A2(R)为： A3 A2 f 3 d 2 f 6 除设关系R(X,Y)和S(Y,Z)，X，Y，Z为属性组。X属性上的值为Xi。则： R÷S= {t[X] | t∈R ∧ ΠY(S)⊆YX} 求 R÷S步骤如下： 求ΠX(R) 求ΠY(S) YX为Xi在R中的象集，他表示R中属性组X上值为xi的诸元素在Y上分量的集合 R÷S运算结果为：象集YX包含了ΠY(S)的xi 求象集YX的方法为：对于每个值xi，xi∈Πx(R),求ΠY(σX=xi(R)) 看个例子 关系R中A可以取{a1,a2,a3,a4} a1的象集为a1的象集为｛(b1,c2),(b2,c3),(b2,c1)}a2的象集为｛(b3,c7),(b2,c3)}a3的象集为｛(b4,c6)}a4的象集为｛(b6,c6)}S在（B,C）上的投影为｛(b1,c2),(b2,c3),(b2,c1) }. 因此只有a1的象集包含了S在（B，C）上的投影，所以 R➗S={a1} 7.掌握等值连接与自然连接之间的区别连接是在两个关系的笛卡尔积基础上再做选择运算得到的关系。如果连接条件相等，则称是等值连接，否则为不等值连接。在等值连接的基础上去除重复的列，则为自然连接。 一张图说明 第三章1.SQL的特点和基本概念SQL的特点(1)综合统一数据库系统的主要功能是通过数据库支持的数据语言来实现的，SQL集数据定义语言、数据操纵语言、数据控制语言的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动 (2)高度非过程化只要提出做什么，而无须指明怎么做，因此无需了解存储路径。 (3)面向集合的操作方式SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合 (4)以一种语法结构提供多种使用方式SQL既是独立的语言，又是嵌入式语言，能够嵌入到高级语言（java、c++等）程序中 (5)语言简洁，易学易用设计巧妙，语言简洁，接近口语 SQL的基本概念支持SQL的关系数据库管理系统同样支持关系数据库的三级模式结构。其中外模式包括若干视图和部分基本表，数据库模式包括若干基本表，内模式包括若干存储文件。 2.掌握创建数据库、表、架构（模式）、完整性的SQL语句(1)SQL模式的创建和删除模式创建模式(架构)是一个对象的容器，它包含表、视图、存储过程等数据对象的容器。从包含关系上来讲，模式位于数据库内部，而数据库位于服务器内部。 SQL模式的创建可以用CREATE语句实现，句法如下： 1CREATE SCHEMA&lt;模式名&gt;AUTHORIZATION &lt;用户名&gt; 例如 1CREATE SCHEMA “S-T” AUTHORIZATION WANG 为用户wang定义了一个学生-课程模式S-T 模式删除当一个SQL模式及其所属的基本表、视图等元素都不需要时，可以用DROP语句删除这个SQL模式： 1DROP SCHEMA &lt;模式名&gt;[CASCADE|RESTRICT] CASCADE（级联）方式：执行DROP语句时，把SQL模式及其下属的基本表、视图、索引等所有元素全部删除。 RESTRICT（限制）方式：执行DROP语句时，只有当SQL模式中没有任何下属元素时，才能删除SQL模式。 (2)基本表的创建SQL使用CREAT TABLE语句定义基本表 1CREATE TABLE &lt;表名&gt;(&lt;列定义&gt;[&#123;,&lt;列定义&gt;,&lt;完整性约束&gt;&#125;]) 例如 例如：建立一个学生基本表 12345CREATE TABLE S ( S# CHAR(4), SN CHAR(8), AGE SMALLINT, SEX CHAR(2) DEFAULT’男‘, DEPT CHAR(2)); 3.什么是唯一索引？聚簇索引？定义索引的SQL语句是什么？理解聚簇索引的作用及使用时应注意的问题。(1)唯一索引unique（distinct）：唯一性索引，不允许表在索引列不同的行取相同值。若已有相同值存在，则系统给出相关信息，不建此索引。系统并拒绝违背唯一性的插入、更新。 (2)聚簇索引cluster：聚簇索引，将数据行的键值在表内排序并存储对应的数据记录，使得数据表记录的物理顺序与索引项的顺序一致。当以某字段作为关键字建立聚集索引时，表中数据以该字段作为排序根据。因此，一个表只能建立一个聚集索引，但该索引可以包含多个列（组合索引） 经常更新的列不宜建立聚簇索引。 (3)定义索引在SQL语言中，建立索引使用CREATE INDEX语句，其格式一般为 1CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&#123;,&lt;列名&gt;&#125;]) (4)聚簇索引的作用及使用时应注意的问题作用：提高某个属性（属性组）的查询速度。 注意：经常更新的列不宜建立聚簇索引。 4.数据的查询与更新。 Select（单表查询、条件表示、聚集函数；连接、存在谓词、嵌套、集合查询等），insert 、delete 、update。(1)单表查询和条件查询单表查询是指仅涉及一个表的查询 1SELECT S#,AGE,SEX,… FROM S 选择列123查询制定列SELECT Sno,SnameFROM Student; 123查询全部列SELECT *FROM Student; 123查询算术表达式计算的值SELECT Sname,2014-SageFROM Student; 123查询函数计算的值SELECT Sname,LOWER(Sdept)FROM Student; 123改变查询结果的列标题SELECT Sname,2014-Sage BIRTHDAYFROM Student; 选择行123456消除取值重复的行SELECT DISTINCT SnoFROM SC;若无指定DISTINCT,则默认为ALL,等价于SELECT ALL SnoFROM SC; 1234567891011121314151617查询满足条件的行1.比较大小SELECT Sno,SnameFROM StudentWHERE Sdept='CS';2.确定范围SELECT Sno,SnameFROM StudentWHERE Sage BETWEEN 20 AND 23;3.确定集合SELECT Sno,SnameFROM StudentWHERE Sdept IN('CS','MA','IS');4.涉及空值的查询SELECT Sno,SnameFROM StudentWHERE Sdept IS NULL; ORDER BY子句(升序 ASC 降序 DESC)1234按学号降序查询SELECT Sno,SnameFROM StudentORDER BY Sno DESC; (2)聚集函数 函数 作用 COUNT([DISTINCT\ ALL] &lt;列名&gt;) 统计一列中值的个数 SUM([DISTINCT\ ALL] &lt;列名&gt;) 计算一列值的总和（此列必须是数值型） AVG([DISTINCT\ ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须是数值型） MAX([DISTINCT\ ALL] &lt;列名&gt;) 求一列值中的最大值 MIN([DISTINCT\ ALL] &lt;列名&gt;) 求一列值中的最小值 (3)连接在查询中，同时涉及两个或两个以上的表，要根据表中数据的情况作连接。 连接查询包括： 等值连接 自身连接 外连接 1）等值连接示例：查询学习课程名为‘MATHS’的学生学号和姓名。 1234select s.sno,sname from s,sc,c where s.sno=sc.sno and sc.cno=c.cnoand cname='MATHS'; 2)自连接一个表与其自身进行的连接 示例：检索每一门课的间接先修课 123SELECT A.CNO,B.CPNO FROM (COURSE A, COURSE B)WHERE A.CPNO=B.CNO 3）外连接在通常的连接操作中，只有满足条件的元组才能作为结果输出。但是有时想以Student表作为主体列出所有学生的选课情况，若某个学生没有选课，则仍把Student作为悬浮元组保存在结果关系中。 示例 12SELECT student.*,SC.Cno,SC.GradeFROM student LEFT OUTER JOIN SC ON (student.sno=SC.sno); 去除重复元素 12SELECT student.*,SC.Cno,SC.GradeFROM student LEFT OUTER JOIN SC USING(Sno); (4)嵌套查询Select在一个select语句的where子句中，又出现了另一个select语句，这种查询称为嵌套查询。子查询中还可以嵌入子查询。 in 子查询123456select SNO,SNAMEfrom Swhere SNO in (select SNO from SC where CNO = 'C1'); any/all子查询ANY ：表达式的值至少与子查询结果中的一个值相比能满足比较运算符 。 ALL：表达式的值与子查询结果中的所有的值相比都满足比较运算符。 示例：检索至少有一门成绩超过学生S4一门成绩的学生学号 1234SELECT distinct sno FROM SC WHERE grade &gt;any (SELECT grade FROM SC WHERE sno='S4')AND sno&lt;&gt;'S4' 示例：检索平均成绩最高的学生学号 1234567select SNOfrom SCgroup by SNOhaving avg(GRADE) &gt;= all (select avg(GRADE) from SC group by SNO); exists查询带有EXISTS谓词的子查询不返回任何实际数据，它只产生逻辑真值“true”或逻辑假值“false”。 示例：列出选修了1号课程的学生的学号及姓名 12345select SNO,SNAMEfrom S where exists (select * from SC where SNO = S.SNO and CNO = '1') 示例：检索男生中不学C2课程的学生姓名。 123select sname from s where s.sex='M' and not exists(select * from sc where s.sno=sc.sno and cno='C2') not exists–当集合为空，值为true，否则为false (5)集合查询Select语句的结果是一个元组的集合，多个Select语句的结果可以进行集合操作 属性个数必须一致 对应的类型必须一致 属性名无关，最后结果集采用第一个结果的属性名 缺省为自动去除重复元组 只能在整个语句的最后使用一次Order By 集合并： union 集合交：intersect 集合差：except 示例：查询姓“张”的学生及年龄不大于19岁的学生(按年龄排序) 12345678Select sno,sname as Name ,age From S Where sname like '张%' Union Select sno,sname,age From S Where age &lt;=19 Order By age; 示例：求选修了001或002号而没有选003号课程的学生号 1234567（select SNO from SC where CNO = ‘C1’ or CNO = ‘C2’ ） except（select SNO from SC where CNO = ‘C3’） (5)INSERT插入单个元组的INSERT语句的格式为： 123INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2&gt;...)]VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]...) 示例：插入一条数据 12Insert Into S Values ('s8','张三',21,'M','JSJ') 示例：插入子查询结果 1234567INSERT INTO s_grade(sno,avg_grade)SELECT sno,avg(grade)FROM SC WHERE sno IN (SELECT sno FROM S WHERE sex='M') GROUP BY sno HAVING avg(grade)&gt;80 (6)UPADTE1234update 表名 set 列名 = 表达式 | 子查询 列名 = [，表达式 | 子查询]… [where 条件表达式] 示例：将S1学生转入CS系 123Update SSet dept = ‘CS'Where sno = 'S1‘ 示例：所有学生年龄加1 12Update SSet age = age + 1 示例：(带子查询的修改)将计算机系全体学生的成绩置零。 12345Update SCSet grade =0Where 'CS‘=(Select Sdept From Student Where Student.Sno=SC.Sno) (7)DELETEDELETE语句的功能是从指定表中删除满足 WHERE子句条件的所有元组。如果省略WHERE子句，表示删除表中全部元组，但表的定义仍在字典中。也就是说，DELETE语句删除的是表中的数据，而不是关于表的定义。 123DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;] 5.判断相关子查询？不相关子查询？相关子查询子查询的查询条件依赖于父查询 示例：找出每个学生超过她自己选修课程平均成绩的课程号 123456select SNO,Cnofrom SC xwhere Grade &gt;= (select AVG(SNO) from SC y where y.sno=s.sno) 内层查询是求一个学生的平均成绩，至于哪个学生的平均成绩还要看x.Sno的值，而该值是与父查询相关的。 不相关子查询子查询的查询条件不依赖于父查询 123456select SNO,SNAMEfrom Studentwhere SNO in (select SNO from SC where CNO = 'C1'); 6.空值的性质、有关处理空值就是“不知道”或“不存在”或“无意义”的值，取空值一般有以下情况： 该属性应该有一个值，但目前不知道它具体的值。如漏填的年龄 该属性不应该有值。如缺考考生的成绩 由于某种原因不便于填写，如不想让其他人知道的电话号码 空值产生 插入数据时，没有赋值的属性产生空值，修改数据为空也产生空值 空值判断 判断一个属性是否为空，用IS NULL 或 IS NOT NULL来判断 空值的约束条件 属性定义中有NOT NULL约束条件不能取空值，加了UNIQUE限制的不能取空值，码属性不能取空值 空值的算数运算、比较运算和逻辑运算 空值与空值算数运算结果为空 空值与另一个值比较结果为UNKNOWN 7.视图的定义、查询等语句是从基本表(或其他视图)中导出的虚表(结果集) 定义视图123456Create View CS_Stu as Select sno,sname,ssex From Student Where sdept = ‘CS’ WITH CHECK OPTION 其中，子查询可以是任意SELECT语句 在定义视图时加上WITH CHECK OPTION子句，以后对该视图进行插入、修改和删除操作时，关系数据库系统会自动加上sdept = ‘CS’的条件。 视图不仅可以建立在一个或多个基本表上，也可以在一个或多个已定义好的视图上，或建立在基本表与视图上 查询视图123Select sno,snameFrom CS_StuWhere ssex = ‘M’ 视图定义好后，查询操作和基本表一样 8.视图作用(1)视图能够简化用户操作用户可以将注意力集中在所关心的数据上，定义的视图可以使数据库看起来结构简单、清晰，并且可以简化用户的数据查询操作。 (2)视图能够使用户能以多种角度看待同一数据视图机制能够使用户能以不同方式看待同一数据，当许多不同种类用户共享同一数据库时，这种灵活性十分重要。 (3)视图对重构数据库提供了一定程度的逻辑独立性当数据库的逻辑结构改变时，应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能查找数据 (4)视图能对机密数据提供保护对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。 (5)适当的利用视图可以更清晰的表达查询9.如何用视图实现安全保护，举例对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。例如Student表设计全校15个院系的学生数据，可以在其上定义15个视图，每一个视图只包含一个院系的学生数据，只允许每个院系的主人查询和修改本院系的学生视图。 第四章1.什么是数据库的安全性数据库安全性是指保护数据库以防止不合法使用所造成的数据泄漏、更改或破坏 2.有几种安全控制策略 用户标识和鉴定 多层存取控制 视图 审计 数据加密 3.控制（授权等）语句的定义和作用(1)授权123grant 表级权限 on &#123;表名 | 视图名&#125; to &#123;用户 [，用户]… | public&#125; with grant option 语义为对指定操作对象的指定操作权限授予指定用户 发出GRANT语句的可以是数据库管理员，也可以是数据库对象创建者 如果指定了with grant option子句，则获得某种权限的用户还可以把这种权限再授予其他用户，反之则不能传播该权限。 示例：把查询Student表的权限授予给用户U1 123GRANT SELECTON TABLE StudentTO U1 (2)回收授予用户的权限可以由管理员或其他授权者用REVOKE语句收回，一般格式为 12revoke 表级权限 on &#123;表名 | 视图名&#125; from &#123;用户 [，用户]… | public&#125; 示例：把用户U1查询Student表的权限收回 123REVOKE SELECTON TABLE StudentFROM U1 CASCADE 将用户U1权限收回的同时，由于U1将权限赋给了U2，因此级联CASCADE收回了U2的权限。 4.有哪两种存取控制方法，主体和客体指的是什么存取控制方法分为自主存取控制和强制存取控制 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。 主体是系统中的活动实体，既包括数据库管理系统所包括的实际用户，也包括代表用户的各种进程。客体是系统中的被动实体，是受主体操作的，包括文件、基本表、索引、视图等。 第五章1.什么是数据库的完整性数据库的完整性是指数据的正确性和相容性。正确性是指数据是符合现实世界语义、反应当前实际状况的；数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。 2.为维护数据库的完整性，数据库管理系统必须能实现哪三种功能 提供定义完整性约束条件的机制 提供完整性检查方法 提供违约处理 3.删除被参照关系的元组时可能采取哪三种作法？修改被参照关系中的主码时可能采取哪三种作法？删除被参照关系的元组或修改了主码值，可以通过拒绝执行、级联删除和设置为空值3种方法 4.掌握SQL Server中的实体和参照完整性的语句格式，并会应用。SQL Server中可以定义几种约束。PRIMARY KEY约束 DEFAULT约束 CHECK约束 UNIQUE约束 FOREIGN KEY约束 5.创建触发器的SQL语句触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程 触发器保存在数据库服务器中 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器 触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力 触发器又叫做事件-条件-动作（event-condition-action）规则。当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。 12345CREATE TRIGGER [OWNER.]TRIGGER_NAMEON &#123;[OWNER].TABLE_NAME|VIEW&#125; &#123; FOR | AFTER | INSTEAD OF &#125; &#123;INSERT|UPDATE|DELETE&#125; AS SQL_Statements TRIGGER_NAME：触发器名称 ON TABLE_NAME：触发动作相关联的表 AFTER或FOR：触发器在操作(如INSERT)执行后被激发 INSTEAD OF：执行触发器而不是执行触发SQL语句(即INSERT等)，从而替代触发语句的操作 INSERT|UPDATE|DELETE：指定在发生哪一种数据动作时被触发 SQL_Statements：触发器执行的SQL语句]]></content>
  </entry>
  <entry>
    <title><![CDATA[连接池介绍--C3P0连接池]]></title>
    <url>%2F2017%2F05%2F29%2FJAVA%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D-C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[背景​ 初学JDBC技术来连接数据库时，每一次连接DBMS都需要很繁琐的执行以下步骤： 123456//1.加载驱动Class.forName("com.mysql.jdbc.Driver");//2.连接数据库URLString url = "jdbc:mysql://localhost:3306/test?" +"user=root&amp;password=root";//3.获取数据库连接conn = DriverManager.getConnection(url); ​ 不论是一次小小的查询还是添加一条记录，你都得老老实实的按这三步走（加载驱动，连接数据库URL,获取数据库连接）。然而当系统变得复杂了，数据库的操作更加频繁，系统的性能也会随之下降。 ​ 有句话说“数据库连接很昂贵”。每一次创建一个数据库连接，他的内部都会执行着： “DriverManager”检查并注册驱动程序。 在驱动程序类中调用“connect(url…)”方法。 connect方法根据我们请求的“connUrl”，创建一个“Socket连接”，连接到IP为“your.database.domain”，默认端口3306的数据库。 创建的Socket连接将被用来查询我们指定的数据库，并最终让程序返回得到一个结果。 ​ 有时数据库连接所耗费的时间甚至大于执行查询操作所花费的时间，如果有一种方法，能够预先加载好一些连接对象，每当要执行数据库操作时，无需重新建立连接，只需使用预先加载好的一个连接对象，那么系统的性能将会大大的提高。 连接池就是为解决这类问题存在的。 连接池定义数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。 原理简单的说，连接池就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 于是，通过连接池，我们只要在系统启动时预先加载好一些连接对象，当需要的时候再也不需要繁琐的步骤，现成的给你准备好啦，拿了就用，用完了放回去下次再接着用，系统加载的速度会变快，性能也会随之增加了。 几种主流的java连接池C3P0连接池C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能。目前使用它的开源项目有hibernate，spring等。是一个成熟的、高并发的JDBC连接池库，用于缓存和重用PreparedStatements支持。c3p0具有自动回收空闲连接功能。 主要特性：1、编码的简单易用。2、连接的复用。3、连接的管理 DBCP是Apache上的一个 Java连接池项目，也是 tomcat使用的连接池组件。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。dbcp没有自动的去回收空闲连接的功能。 ProxoolProxool是一个Java SQL Driver驱动程序，提供了对你选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中。完全可配置。快速，成熟，健壮。可以透明地为你现存的JDBC驱动程序增加连接池功能。 C3P0连接池使用准备 下载 C3P0连接池jar包和mysql驱动,导入工程文件。 创建配置文件c3p0-config.xml。（在src根目录下，名字不能改） 书写连接池配置12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;!-- This is default config! --&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/contacts?characterEncoding=utf8&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123456&lt;/property&gt; &lt;property name="acquireIncrement"&gt;5&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="minPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;20&lt;/property&gt; &lt;property name="maxStatements"&gt;0&lt;/property&gt; &lt;property name="maxStatementsPerConnection"&gt;5&lt;/property&gt; &lt;/default-config&gt; &lt;!-- This is my config for mysql--&gt; &lt;named-config name="mysql"&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123456&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxIdleTime"&gt;30&lt;/property&gt; &lt;property name="maxPoolSize"&gt;100&lt;/property&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;property name="maxStatements"&gt;200&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 配置信息主要是填写数据库驱动、数据库名称、数据库用户名、密码等等，一般修改这些信息，其他的按默认的就可以了。 启动C3P0连接池完成了前面的准备工作和信息配置，下面就正式进入连接池的操作了。 建立一个C3P0Demo测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException; import com.mchange.v2.c3p0.ComboPooledDataSource; /** * 数据库工具类 * @author cloud * */ public class C3P0Util &#123; static ComboPooledDataSource cpds=null; static&#123; cpds = new ComboPooledDataSource();//这是mysql数据库 &#125; /** * 获得数据库连接 * @return Connection */ public static Connection getConnection()&#123; try &#123; return cpds.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); System.out.println("连接失败"); return null; &#125; &#125; /** * 放回连接对象，close方法并不是关闭，而是更改该连接对象的状态为可用。 * @param conn */ public static void close(Connection conn)&#123; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 在test数据库中创建一个student表 在刚刚创建的测试类C3P0Demo种添加如下main方法，插入1条数据 NO:201701 NAME:TOM 12345678910111213141516171819202122232425262728 /** * 测试DBUtil类 * @param args * */ public static void main(String[] args) &#123; Connection conn = C3P0Util.getConnection(); System.out.println("连接成功"); //插入信息的sql语句 String sql = "insert into student(no,name)values(?,?)"; try&#123; //获取PreparedStatement对象 PreparedStatement ps = conn.prepareStatement(sql); //对sql语句对占位符进行动态赋值 ps.setString(1, "201701"); ps.setString(2, "TOM"); //执行更新操作 ps.executeUpdate(); ps.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭数据库连接 C3P0Util.close(conn);&#125; &#125; 运行程序，执行结果如下 查看数据库，可以看到刚刚插入的数据已经成功插入，证明C3P0数据库配置成功。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>连接池</tag>
        <tag>C3P0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS上基于Github的hexo博客]]></title>
    <url>%2F2017%2F05%2F19%2FMacOS%E4%B8%8A%E5%9F%BA%E4%BA%8EGithub%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[​ 本教程主要是为了记录此博客的搭建过程，让自己对学习搭建博客的历程有一个更清晰的认识，而不是稀里糊涂把各种官方文档啊博客啊七拼八凑的倒腾出一个博客，自己不明不白的都不知道为什么就搭起来了。 ​ 很早以前就有搭建博客的想法了，既然想好了以后是要走技术路线，起码要有一个像样的博客。并且我可以在博客里记录最近学的一块知识点，或者新技术等等，并且讲这些东西系统的、规范化的整理起来，巩固自己的同时，也能把这些东西让其他需要的人看到，这是一种很棒的感觉！ ​ 像这么一个博客，我从hexo是什么都不知道到搭建出这么一个像样的博客配置好主题推送到GitHubPage上花了将近快四个小时，中间遇到了无数的坑，磕磕绊绊的也完成了。所以只要有肯折腾，对自己有信心，没有什么做不出来。 ​ 那么下面就正式进入教程吧： 1. 准备工具–配置搭建环境 操作系统：MacOS Github账号 包管理工具：Homebrew 版本控制：git Node.js hexo 1.1 GitHub账号 百度GitHub进入官网 Sign up for Github 填写账号信息，什么姓名啊邮箱啊 选择免费的用户计划 完成注册 参考教程：github注册教程地址 1.2 Homebrew包管理工具 作用：在Mac中方便的安装软件或者卸载软件，例如git、node.js、等等。 安装 Homebrew 在命令行输入： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 1.3 版本控制工具：git两种安装Git的方法: 在安装homebrew的基础上，用命令行 1brew install git 从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 1.4 安装Node.jsNode.js可以生成静态页面，也有两种安装方式： 在安装好包管理工具的基础上，用brew来安装，在命令行输入 1brew install node 某些地区某些时间可能会被墙，如果网络状况不好那可能是被墙污染了，采用第二种方式即可 在node.js官网下载安装包安装 1.5 安装hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令： 1sudo npm install -g hexo 接着会提示输入管理员密码，输入完毕后等待安装完成 2. 初始化本地博客​ 以上工作完成以后，可以说是万事俱备了。该有的都有了，那么博客就可以正式的开始搭建了。 ​ 第一步：找一个存放你整个博客站点文件的目录。以我的为例，我在/Users/yunhuang 下创建了一个名为myblog的文件，用于存放我的博客站点。 ​ 第二步：创建成功后 1cd /Users/yunhuang/myblog ​ cd来到你创建的目录下，执行hexo init命令 1hexo init blog 等待安装完成后的提示： 再一次cd到初始化创建产生的blog文件 1cd /Users/yunhuang/myblog/blog 然后执行如下命令，安装npm 1npm install 进入blog文件内，看一看hexo初始化后的文件目录是不是包含以下： 1234567_config.yml db.json node_modules package.jsonscaffoldssourcethemes 到此，博客初始化就算完成了，已经迫不及待的想打开看看自己搭建博客的样子，测试一下吧，在命令行打开服务测试一下效果 1hexo server 打开浏览器，输入站点的默认端口http://localhost:4000 到此，一个本地的博客初始化就算完成啦！ 3. 推送到GitHub​ 本地的博客搭建好啦，但只能自己玩单机给自己嗨。这时候就需要用GitHub page提供的免费空间来存储我们的博客了。 3.1 创建GitHub仓库​ GitHub提供了免费的空间给我们存放站点，那自然是要在GitHub上创建一个仓库，仓库等名字不能乱取，为了让GitHub知道这不是一个普通的仓库，而是作为GitHub page的站点仓库，就必须采用固定的命名方式用户名.github.io。如Cloud-Wong.github.io。 建好以后主页大致就是这么一个样子。注意，左上角的命名规范！要严格按照用户名.github.io这么搞才行。 3.2 推送站点到GitHub上仓库建好了，回到我们的命令行来。cd到我们初始化好的blog文件上。执行 1vim _config.yml 滑到最后可以看到 1234deploy: type: git repository: https:// branch: master type如果不是git就改成git，repository这个参数代表了需要推送到的地址。回到刚刚新建好的GitHub仓库，复制 然后粘贴到repository后面 修改后： 1234deploy: type: git repository: https://github.com/Cloud-Wong/Cloud-Wong.github.io.git branch: master 当然你如果不想在控制台用vim编译器修改，直接打开blog文件夹，找到_config.yml配置文件，拉到最后修改保存也可以。 ⚠️注意：配置信息内到所有参数的冒号后面都要有一个空格！！！否则hexo命令会报错。 在blog文件夹下执行命令生成静态文件： 1hexo g 123456此时若出现如下报错：ERROR Local hexo not found in ~/blogERROR Try runing: &apos;npm install hexo --save&apos;则执行命令：npm install hexo --save若无报错，自行忽略此步骤。 静态页面生成以后，就可以把整个站点推送到GitHub上了，执行 1hexo d 如果说无法连接到git，执行npm install hexo-deployer-git --save，然后再次执行hexo generate和hexo deploy命令。 成功连接后，就可以打开浏览器输入cloud-wong.github.io验证。你将会看到和之前在本地初始化一样的界面。 参考链接参考博客：与佳期的个人博客 官方文档： hexo GitHub page Homebrew]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建博客</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java静态使用]]></title>
    <url>%2F2017%2F05%2F18%2Fjava%E9%9D%99%E6%80%81%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[静态什么时候用？ 静态变量：当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以修饰成静态。只要数据在对象中都是不同的，就是对象的特有数据，这是非静态的；如果在对象中的数据是相同的，对象不需要修饰，不需要存储在对象中，设为静态即可。 静态函数：函数是否修饰为静态，就参考该方法是否访问到了对象中的特有数据，如果有就用静态。 构造函数的执行顺序 JAVA中执行顺序 父类静态块-》自身静态块-》父类块-》父类构造器-》自身块-》自身构造器 123456789101112131415/* DOG父类 */ public class Dog &#123; public Dog() &#123; System.out.println(&quot;Dog&quot;); &#125; static&#123; System.out.println(&quot;super static block&quot;); &#125; &#123; System.out.println(&quot;super block&quot;); &#125; &#125; 1234567891011121314151617181920/** * 子类藏獒 */ public class Mastiff extends Dog &#123; public Mastiff() &#123; System.out.println(&quot;Mastiff&quot;); &#125; &#123; System.out.println(&quot;block&quot;); &#125; static &#123; System.out.println(&quot;static block&quot;); &#125; public static void main(String[] args)&#123; Mastiff mastiff=new Mastiff(); &#125; &#125; 运行结果： super static block static block super block Dog block Mastiff 也就是说此时的运行顺序为： 父类静态块 自身静态块 父类块 父类构造器 自身块 自身构造器]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
